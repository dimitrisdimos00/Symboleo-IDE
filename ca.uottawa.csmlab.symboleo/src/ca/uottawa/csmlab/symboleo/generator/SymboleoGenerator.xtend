///*
// * generated by Xtext 2.25.0
// */
package ca.uottawa.csmlab.symboleo.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import ca.uottawa.csmlab.symboleo.symboleo.RegularType
import ca.uottawa.csmlab.symboleo.symboleo.Model
import java.util.ArrayList
import ca.uottawa.csmlab.symboleo.symboleo.Enumeration
import ca.uottawa.csmlab.symboleo.symboleo.Parameter
import ca.uottawa.csmlab.symboleo.symboleo.VariableRef
import ca.uottawa.csmlab.symboleo.symboleo.Ref
import ca.uottawa.csmlab.symboleo.symboleo.VariableDotExpression
import ca.uottawa.csmlab.symboleo.symboleo.AssignExpression
import ca.uottawa.csmlab.symboleo.symboleo.Expression
import ca.uottawa.csmlab.symboleo.symboleo.And
import ca.uottawa.csmlab.symboleo.symboleo.Or
import ca.uottawa.csmlab.symboleo.symboleo.Equality
import ca.uottawa.csmlab.symboleo.symboleo.Comparison
import ca.uottawa.csmlab.symboleo.symboleo.Plus
import ca.uottawa.csmlab.symboleo.symboleo.Minus
import ca.uottawa.csmlab.symboleo.symboleo.Div
import ca.uottawa.csmlab.symboleo.symboleo.Multi
import ca.uottawa.csmlab.symboleo.symboleo.PrimaryExpressionFunctionCall
import ca.uottawa.csmlab.symboleo.symboleo.NegatedPrimaryExpression
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionTrue
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionFalse
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionDouble
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionInt
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionEnum
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionString
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionParameter
import ca.uottawa.csmlab.symboleo.symboleo.PrimaryExpressionRecursive
import ca.uottawa.csmlab.symboleo.symboleo.TwoArgMathFunction
import ca.uottawa.csmlab.symboleo.symboleo.OneArgMathFunction
import ca.uottawa.csmlab.symboleo.symboleo.TwoArgStringFunction
import ca.uottawa.csmlab.symboleo.symboleo.OneArgStringFunction
import ca.uottawa.csmlab.symboleo.symboleo.Obligation
import ca.uottawa.csmlab.symboleo.symboleo.Power
import ca.uottawa.csmlab.symboleo.symboleo.Variable
import ca.uottawa.csmlab.symboleo.symboleo.Proposition
import ca.uottawa.csmlab.symboleo.symboleo.POr
import ca.uottawa.csmlab.symboleo.symboleo.PAnd
import ca.uottawa.csmlab.symboleo.symboleo.PEquality
import ca.uottawa.csmlab.symboleo.symboleo.NegatedPAtom
import ca.uottawa.csmlab.symboleo.symboleo.PAtomPredicate
import ca.uottawa.csmlab.symboleo.symboleo.PAtomEnum
import ca.uottawa.csmlab.symboleo.symboleo.PAtomRecursive
import ca.uottawa.csmlab.symboleo.symboleo.PComparison
import ca.uottawa.csmlab.symboleo.symboleo.PAtomVariable
import ca.uottawa.csmlab.symboleo.symboleo.PAtomPredicateTrueLiteral
import ca.uottawa.csmlab.symboleo.symboleo.PAtomPredicateFalseLiteral
import ca.uottawa.csmlab.symboleo.symboleo.PAtomIntLiteral
import ca.uottawa.csmlab.symboleo.symboleo.PAtomStringLiteral
import ca.uottawa.csmlab.symboleo.symboleo.PAtomDoubleLiteral
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunction
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionHappens
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionHappensWithin
import ca.uottawa.csmlab.symboleo.symboleo.Event
import ca.uottawa.csmlab.symboleo.symboleo.VariableEvent
import ca.uottawa.csmlab.symboleo.symboleo.PowerEvent
import ca.uottawa.csmlab.symboleo.symboleo.ObligationEvent
import ca.uottawa.csmlab.symboleo.symboleo.ContractEvent
import ca.uottawa.csmlab.symboleo.symboleo.PointExpression
import ca.uottawa.csmlab.symboleo.symboleo.PointAtomParameterDotExpression
import ca.uottawa.csmlab.symboleo.symboleo.PointFunction
import ca.uottawa.csmlab.symboleo.symboleo.PointAtomObligationEvent
import ca.uottawa.csmlab.symboleo.symboleo.PointAtomContractEvent
import ca.uottawa.csmlab.symboleo.symboleo.PointAtomPowerEvent
import ca.uottawa.csmlab.symboleo.symboleo.IntervalExpression
import ca.uottawa.csmlab.symboleo.symboleo.IntervalFunction
import ca.uottawa.csmlab.symboleo.symboleo.ObligationState
import ca.uottawa.csmlab.symboleo.symboleo.PowerState
import ca.uottawa.csmlab.symboleo.symboleo.ContractState
import ca.uottawa.csmlab.symboleo.symboleo.SituationExpression
import ca.uottawa.csmlab.symboleo.symboleo.Timevalue
import ca.uottawa.csmlab.symboleo.symboleo.TimevalueInt
import ca.uottawa.csmlab.symboleo.symboleo.TimevalueVariable
import ca.uottawa.csmlab.symboleo.symboleo.ThreeArgStringFunction
import ca.uottawa.csmlab.symboleo.symboleo.ThreeArgDateFunction
import ca.uottawa.csmlab.symboleo.Helpers
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionSHappensBefore
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionWHappensBefore
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionDate
import ca.uottawa.csmlab.symboleo.symboleo.PAtomDateLiteral
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionHappensAfter
import ca.uottawa.csmlab.symboleo.symboleo.ParameterType
import ca.uottawa.csmlab.symboleo.symboleo.PowerFunction
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionWHappensBeforeEvent
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionSHappensBeforeEvent
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionOccurs
import ca.uottawa.csmlab.symboleo.symboleo.Situation
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionIsEqual
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionIsOwner
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionCannotBeAssigned
import ca.uottawa.csmlab.symboleo.symboleo.OtherFunction
import ca.uottawa.csmlab.symboleo.symboleo.PAtomFunction
import ca.uottawa.csmlab.symboleo.symboleo.Attribute
import ca.uottawa.csmlab.symboleo.symboleo.PFObligationSuspended
import ca.uottawa.csmlab.symboleo.symboleo.PFObligationResumed
import ca.uottawa.csmlab.symboleo.symboleo.PFObligationDischarged
import ca.uottawa.csmlab.symboleo.symboleo.PFObligationTerminated
import ca.uottawa.csmlab.symboleo.symboleo.PFObligationTriggered
import ca.uottawa.csmlab.symboleo.symboleo.PFContractSuspended
import ca.uottawa.csmlab.symboleo.symboleo.PFContractResumed
import ca.uottawa.csmlab.symboleo.symboleo.PFContractTerminated

//
/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SymboleoGenerator extends AbstractGenerator {

  val assets = new ArrayList<RegularType>
  val events = new ArrayList<RegularType>
  val roles = new ArrayList<RegularType>
  val enumerations = new ArrayList<Enumeration>
  val parameters = new ArrayList<Parameter>
  val variables = new ArrayList<Variable>
  
  val allObligations = new ArrayList<Obligation>
  val allSurvivingObligations = new ArrayList<Obligation>
  val allPowers = new ArrayList<Power>

  val eventVariables = new ArrayList<Variable>
  
  val preconditions = new ArrayList<Proposition>
  val postconditions = new ArrayList<Proposition>
  val constraints = new ArrayList<Proposition>

  def void generateHFSource(IFileSystemAccess2 fsa, Model model) {
    parse(model)
    compileDomainTypes(fsa, model)  
  }

  def void parse(Model model) {
    parameters.addAll(model.parameters)
    variables.addAll(model.variables)

    for (domainType : model.domainTypes) {
      if (domainType instanceof RegularType) {
        var RegularType base = Helpers.getBaseType(domainType)
        if (base !== null) {
          switch base.ontologyType.name {
            case 'Asset': assets.add(domainType as RegularType)
            case 'Event': events.add(domainType as RegularType)
            case 'Role': roles.add(domainType as RegularType)
          }
        }
      } else if (domainType instanceof Enumeration) {
        enumerations.add(domainType as Enumeration)
      }
    }

    // event variables
    for (variable : model.variables) {
      if (events.indexOf(variable.type) != -1) {
        eventVariables.add(variable)
      }
    }
    
    allObligations.addAll(model.obligations)
    allSurvivingObligations.addAll(model.survivingObligations)
    allPowers.addAll(model.powers)

    preconditions.addAll(model.preconditions)
    postconditions.addAll(model.postconditions)
    constraints.addAll(model.constraints)

  }

  def generateSituation(Situation situation) {
  	switch(situation) {
  	  ObligationState:'''«situation.stateName»(obligations.«situation.obligationVariable.name»)'''
  	  PowerState:'''«situation.stateName»(powers.«situation.powerVariable.name»)'''
  	  ContractState:'''«situation.stateName»(self)'''
  	}
  }
  
  def String generatePredicateFunctionString(PredicateFunction predicate) {
    switch (predicate) {
      PredicateFunctionHappens:'''Happens(«generateEventVariableString(predicate.event)»)'''
      PredicateFunctionWHappensBefore:'''WhappensBefore(«generateEventVariableString(predicate.event)», «generatePointExpresionString(predicate.point.pointExpression)»)'''
      PredicateFunctionSHappensBefore:'''ShappensBefore(«generateEventVariableString(predicate.event)», «generatePointExpresionString(predicate.point.pointExpression)»)'''
      PredicateFunctionHappensWithin:'''HappensWithin(«generateEventVariableString(predicate.event)», «generateIntervalExpresionArgString(predicate.interval.intervalExpression)»)'''
      PredicateFunctionWHappensBeforeEvent:'''WhappensBeforeE(«generateEventVariableString(predicate.event1)», «generateEventVariableString(predicate.event2)»'''
      PredicateFunctionSHappensBeforeEvent:'''ShappensBeforeE(«generateEventVariableString(predicate.event1)», «generateEventVariableString(predicate.event2)»'''
      PredicateFunctionHappensAfter:'''HappensAfter(«generateEventVariableString(predicate.event)», «generatePointExpresionString(predicate.point.pointExpression)»)'''
      PredicateFunctionOccurs:'''Occurs(«generateSituation(predicate.situation)», «generateIntervalExpresionArgString(predicate.interval.intervalExpression)»)'''
    }
  }

  def generateEventVariableString(Event event) {
    switch (event) {
      VariableEvent: generateDotExpressionString(event.variable)
      PowerEvent: '''«event.eventName»(powers.«event.powerVariable.name»)'''
      ObligationEvent: '''«event.eventName»(obligations.«event.obligationVariable.name»)'''
      ContractEvent: '''«event.eventName»(self)'''
    }
  }

  def String generatePointExpresionString(PointExpression point) {
    switch (point) {
      PointFunction: '''«point.name»(«generatePointExpresionString(point.arg)», «generateTimeValueString(point.value)», «point.timeUnit»)'''
      PointAtomParameterDotExpression: '''«generateDotExpressionString(point.variable)»'''
      PointAtomObligationEvent: {
        val e = point.obligationEvent as ObligationEvent        
        '''«e.eventName»(obligations.«e.obligationVariable.name»)'''
      }
      PointAtomContractEvent: {
        val e = point.contractEvent as ContractEvent
        '''«e.eventName»(self)'''
      }
      PointAtomPowerEvent: {
        val e = point.powerEvent as PowerEvent
        '''«e.eventName»(powers.«e.powerVariable.name»)'''
      }

    }
  }

  def generateTimeValueString(Timevalue tv) {
    switch (tv) {
      TimevalueInt: tv.value.toString
      TimevalueVariable: generateDotExpressionString(tv.variable)
    }
  }
  
  def generateIntervalExpresionArgString(IntervalExpression interval) {
    switch (interval) {
      IntervalFunction:'''Interval(«generatePointExpresionString(interval.arg1)», «generatePointExpresionString(interval.arg2)»)'''
      SituationExpression: generateSituation(interval.situation)
    }
  }
  
  def variablesToVariableNames() {
  	val vnames = new ArrayList<String>
  	for (v : variables) {
  		vnames.add(v.getName)
  	}
  	return vnames
  }
 
  def String generateExpressionString(Expression argExpression, Boolean ergo) {
    switch (argExpression) {
      Or: '''«generateExpressionString(argExpression.left, ergo)» or «generateExpressionString(argExpression.right, ergo)»'''
      And: '''«generateExpressionString(argExpression.left, ergo)» and «generateExpressionString(argExpression.right, ergo)»'''
      Equality: generateExpressionString(argExpression.left, ergo) + argExpression.op + generateExpressionString(argExpression.right, ergo)
      Comparison: generateExpressionString(argExpression.left, ergo) + argExpression.op + generateExpressionString(argExpression.right, ergo)
      Plus: '''«generateExpressionString(argExpression.left, ergo)» + «generateExpressionString(argExpression.right, ergo)»'''
      Minus: generateExpressionString(argExpression.left, ergo) + " - " + generateExpressionString(argExpression.right, ergo)
      Multi: generateExpressionString(argExpression.left, ergo) + " * " + generateExpressionString(argExpression.right, ergo)
      Div: generateExpressionString(argExpression.left, ergo) + " / " + generateExpressionString(argExpression.right, ergo)
      PrimaryExpressionRecursive: "(" + generateExpressionString(argExpression.inner, ergo) + ")"
      PrimaryExpressionFunctionCall: generateFunctionCall(argExpression, ergo)
      NegatedPrimaryExpression: "not (" + generateExpressionString(argExpression.expression, ergo) + ")"
      AtomicExpressionTrue: "true"
      AtomicExpressionFalse: "false"
      AtomicExpressionDouble: argExpression.value.toString()
      AtomicExpressionInt: argExpression.value.toString()
      AtomicExpressionDate: '''Date("«argExpression.value.toInstant.toString»")'''
      AtomicExpressionEnum: '''«IF ergo»«argExpression.enumItem.name»«ELSE»«argExpression.enumeration.name»(«argExpression.enumItem.name»)«ENDIF»'''
      AtomicExpressionString: '"' + argExpression.value + '"'
      AtomicExpressionParameter: '''«IF variablesToVariableNames.contains(generateDotExpressionString(argExpression.value))»«generateDotExpressionString(argExpression.value)»«ELSE»request.«generateDotExpressionString(argExpression.value)»«ENDIF»'''
    }
  }

  def String generatePropositionString(Proposition proposition) {
    switch (proposition) {
      POr: generatePropositionString(proposition.left) + " or " + generatePropositionString(proposition.right)
      PAnd: generatePropositionString(proposition.left) + " and " + generatePropositionString(proposition.right)
      PEquality: generatePropositionString(proposition.left) + proposition.op + generatePropositionString(proposition.right)
      PComparison: generatePropositionString(proposition.left) + proposition.op + generatePropositionString(proposition.right)
      PAtomRecursive: "(" + generatePropositionString(proposition.inner) + ")"
      NegatedPAtom: "not (" + generatePropositionString(proposition.negated) + ")"
      PAtomPredicate: generatePredicateFunctionString(proposition.predicateFunction)
      PAtomFunction: generateOtherFunction(proposition.function)
      PAtomEnum: proposition.enumeration.name + "(" + proposition.enumItem.name + ")"
      PAtomVariable: generateDotExpressionString(proposition.variable)
      PAtomPredicateTrueLiteral: "true"
      PAtomPredicateFalseLiteral: "false"
      PAtomDoubleLiteral: proposition.value.toString
      PAtomIntLiteral: proposition.value.toString
      PAtomDateLiteral: '''Date("«proposition.value.toInstant.toString»")'''
      PAtomStringLiteral: proposition.value
    }
  }

  def String generateOtherFunction(OtherFunction func) {
  	switch(func){
  	  PredicateFunctionIsEqual: 'IsEqual(' + func.arg1 + ', ' + func.arg2 + ')'
  	  PredicateFunctionIsOwner: 'IsOwner(' + func.arg1 + ', ' + func.arg2 + ')'
  	  PredicateFunctionCannotBeAssigned: 'CannotBeAssigned(' + func.arg1 + ')'
  	}
  }
	
  def String generateDotExpressionString(Ref argRef) {
    val ids = new ArrayList<String>()
    var ref = argRef
    while (ref instanceof VariableDotExpression) {
      ids.add(ref.tail.name)
      ref = ref.ref
    }
    if (ref instanceof VariableRef) {
      ids.add((ref as VariableRef).variable)
    }
    return ids.reverse().join(".")
  }
  
  def String generateParameterType(ParameterType type) {
	if(type.getBaseType!== null)
		if(type.getBaseType.getName.equals("Number"))
			return "Integer"
		else if(type.getBaseType.getName.equals("Date"))
			return "DateTime"
		else
			return type.getBaseType.getName
	else
		return type.getDomainType.getName
  }
  
  def String generateAttributeType(Attribute type) {
  	if(type.getBaseType !== null)
		if(type.getBaseType.getName.equals("Number"))
			return "Integer"
		else if(type.getBaseType.getName.equals("Date"))
			return "DateTime"
		else
			return type.getBaseType.getName
	else
		return type.getDomainType.getName
  }
  
  //INPUT PARAMETERS CONTRACT 
  def generateInputContract()'''
  	transaction InputContract extends Request{
  		«FOR p : parameters»
  		o «generateParameterType(p.type)» «p.name»  
  		«ENDFOR»
  	}
  	
  	'''
  	
  def generatePowerFunction(PowerFunction pf) {
  	switch(pf) {
  	  PFObligationSuspended:'''Suspended(obligations.«pf.norm.name»)'''
  	  PFObligationResumed:'''Resumed(obligations.«pf.norm.name»)'''
  	  PFObligationDischarged:'''Discharged(obligations.«pf.norm.name»)'''
  	  PFObligationTerminated:'''Terminated(obligations.«pf.norm.name»)'''
  	  PFObligationTriggered:'''Triggered(obligations.«pf.norm.name»)'''
  	  PFContractSuspended:'''Suspended(self)'''	
   	  PFContractResumed:'''Resumed(self)'''
   	  PFContractTerminated:'''Terminated(self)'''
  	}
  }
  
  def generateVariables(Boolean ergo)'''
  	«FOR v : variables»
	let «v.getName» = «v.getType.name» { 
  		«val attr = v.getAttributes»
  		«FOR a : attr SEPARATOR ','» 
  			«(a as AssignExpression).name» : «generateExpressionString((a as AssignExpression).value, ergo)»
		«ENDFOR»
		};
		
	«ENDFOR»
  '''

  def generateObligations(String s)'''
    «FOR o : allObligations»
    	«s»obl «o.getName» = «IF o.trigger !== null»«generatePropositionString(o.trigger)» -> «ENDIF»O(«generateDotExpressionString(o.debtor)», «generateDotExpressionString(o.creditor)», «generatePropositionString(o.antecedent)», «generatePropositionString(o.consequent)»); 
  	«ENDFOR»
  '''
  
  def generateSurvivingObligations(String s)'''
    «FOR o : allSurvivingObligations»
    	«s»sobl «o.getName» = «IF o.trigger !== null»«generatePropositionString(o.trigger)» -> «ENDIF»O(«generateDotExpressionString(o.debtor)», «generateDotExpressionString(o.creditor)», «generatePropositionString(o.antecedent)», «generatePropositionString(o.consequent)»); 
  	«ENDFOR»
  '''
  
  def generatePowers(String s)'''
    «FOR o : allPowers»
    	«s»pow «o.getName» = «IF o.trigger !== null»«generatePropositionString(o.trigger)» -> «ENDIF»P(«generateDotExpressionString(o.creditor)», «generateDotExpressionString(o.debtor)», «generatePropositionString(o.antecedent)», «generatePowerFunction(o.consequent)»); 
  	«ENDFOR»
  '''
  
  def generatePrePostConst(ArrayList<Proposition> prop, String keyword, String s)'''
  	«FOR o : prop»
  	    «s»«keyword» «generatePropositionString(o)»;
  	«ENDFOR»
  '''

  def generateLogic(Model model, Boolean ergo)'''
  	namespace NS«model.getDomainName»

  	import org.accordproject.time.TemporalUnit
  	import org.accordproject.time.*
  	
  	contract «model.contractName» over «model.getDomainName» {
  		clause myclause(request : InputContract) : Response {            
  			«IF ergo»«generateVariables(ergo)»
            «generatePrePostConst(preconditions, "pre", "//")»
            «generatePrePostConst(postconditions, "post", "//")»
            «generateObligations("//")»
            «generateSurvivingObligations("//")»
            «generatePowers("//")»
            «generatePrePostConst(constraints, "constr", "//")»
            «ELSE»«generateVariables(ergo)»
            «generatePrePostConst(preconditions, "pre", "")»
            «generatePrePostConst(postconditions, "post", "")»
            «generateObligations("")»
            «generateSurvivingObligations("")»
            «generatePowers("")»
            «generatePrePostConst(constraints, "constr","")»«ENDIF»
  			return Response{}
  		}
  	}
  	
  '''
  	
  def generateModel(Model model, Boolean concerto)'''
  	namespace NS«model.getDomainName»
  	
  	import org.accordproject.«IF concerto»c«ELSE»C«ENDIF»ontract.* 
  	import org.accordproject.runtime.* 
  	
  	asset «model.getDomainName» extends Clause{}
  	
  	«generateInputContract»
  	
  	transaction Response {}
  	«FOR role : roles»
		«generateEntity(role, "participant")»
  	«ENDFOR»
  	«FOR event : events»
  		«generateEntity(event, "concept")»
  	«ENDFOR»
  	«FOR asset : assets»
    	«generateEntity(asset, "asset")»
  	«ENDFOR»
  	
  	«FOR enumeration : enumerations»
  	  	«generateEnumeration(enumeration)»
  	«ENDFOR»
  '''
  
  def String generateFunctionCall(PrimaryExpressionFunctionCall argFunctionCallExp, Boolean ergo) {
    val functionCall = argFunctionCallExp.function
    switch (functionCall) {
      TwoArgMathFunction: functionCall.name + "(" + generateExpressionString(functionCall.arg1, ergo) + "," + generateExpressionString(functionCall.arg2, ergo) + ")"
      OneArgMathFunction: // add more functions????
      '''«IF ergo»
      	«IF functionCall.name.equals("Math.abs")»
      integerAbs(«generateExpressionString(functionCall.arg1, ergo)»)
      	«ENDIF»
      «ELSE»
        «functionCall.name»(«generateExpressionString(functionCall.arg1, ergo)»)
      «ENDIF»'''
      ThreeArgStringFunction: functionCall.name + "(" + generateExpressionString(functionCall.arg1, ergo) + "," + generateExpressionString(functionCall.arg2, ergo) + "," + generateExpressionString(functionCall.arg3, ergo) + ")"
      TwoArgStringFunction: functionCall.name + "(" + generateExpressionString(functionCall.arg1, ergo) + "," + generateExpressionString(functionCall.arg2, ergo) + ")"
      OneArgStringFunction: functionCall.name + "(" + generateExpressionString(functionCall.arg1, ergo) + ")"
      ThreeArgDateFunction:
      '''«IF ergo»
      addDuration(«generateExpressionString(functionCall.arg1, ergo)», Duration{amount: «generateExpressionString(functionCall.value, ergo)», unit: «functionCall.timeUnit»})
      «ELSE»
      Date.add(«generateExpressionString(functionCall.arg1, ergo)», «generateExpressionString(functionCall.value, ergo)», «functionCall.timeUnit»)
      «ENDIF»'''
    }
  }

  def void compileDomainTypes(IFileSystemAccess2 fsa, Model model) {
    val concertom = generateModel(model,true)
    val m = generateModel(model,false)
    val ergol = generateLogic(model, true)   
    val l = generateLogic(model, false)
    fsa.generateFile("./" + model.contractName + "model.cto", concertom)
    fsa.generateFile("./" + model.contractName + "logic.ergo", ergol)
    val ml = m.toString + l.toString
    fsa.generateFile("./" + model.contractName + "model_and_logic.txt", ml)
  }
  
  def String generateEnumeration(Enumeration enumeration)'''      
    enum «enumeration.name» {
    	«FOR item : enumeration.enumerationItems»
    	o «item.name»
    	«ENDFOR»
    }
      
    '''

  def String generateEntity(RegularType rt, String ontology)'''
  	«ontology» «rt.name» «IF rt.regularType !== null»extends «rt.regularType.name»«ENDIF»{
  		«FOR attribute : rt.attributes»
  		o «generateAttributeType(attribute)» «attribute.name»
  		«ENDFOR»
  	}
  	
  	'''

  override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
    for (e : resource.allContents.toIterable.filter(Model)) {
      assets.clear()
      events.clear()
      roles.clear()
      enumerations.clear()
      parameters.clear()
      variables.clear()

      allObligations.clear()
      allSurvivingObligations.clear()
      allPowers.clear()
      
      preconditions.clear()
      postconditions.clear()
      constraints.clear()

      eventVariables.clear()

      System.out.println('generateHFSource: ' + e.contractName)
      generateHFSource(fsa, e)
    }
  }

  override void afterGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
    assets.clear()
    events.clear()
    roles.clear()
    enumerations.clear()
    parameters.clear()
    variables.clear()
    
    allObligations.clear()
    allSurvivingObligations.clear()
    allPowers.clear()

    eventVariables.clear()
  }
}