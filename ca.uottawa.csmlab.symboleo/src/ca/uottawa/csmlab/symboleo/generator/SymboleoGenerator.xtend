///*
// * generated by Xtext 2.25.0
// */
package ca.uottawa.csmlab.symboleo.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import ca.uottawa.csmlab.symboleo.symboleo.RegularType
import java.util.List
import ca.uottawa.csmlab.symboleo.symboleo.Model
import java.util.ArrayList
import ca.uottawa.csmlab.symboleo.symboleo.Enumeration
import ca.uottawa.csmlab.symboleo.symboleo.Parameter
//import ca.uottawa.csmlab.symboleo.symboleo.AssignVariable
import ca.uottawa.csmlab.symboleo.symboleo.VariableRef
import ca.uottawa.csmlab.symboleo.symboleo.Ref
import ca.uottawa.csmlab.symboleo.symboleo.VariableDotExpression
import ca.uottawa.csmlab.symboleo.symboleo.AssignExpression
import ca.uottawa.csmlab.symboleo.symboleo.Expression
import ca.uottawa.csmlab.symboleo.symboleo.And
import ca.uottawa.csmlab.symboleo.symboleo.Or
import ca.uottawa.csmlab.symboleo.symboleo.Equality
import ca.uottawa.csmlab.symboleo.symboleo.Comparison
import ca.uottawa.csmlab.symboleo.symboleo.Plus
import ca.uottawa.csmlab.symboleo.symboleo.Minus
import ca.uottawa.csmlab.symboleo.symboleo.Div
import ca.uottawa.csmlab.symboleo.symboleo.Multi
import ca.uottawa.csmlab.symboleo.symboleo.PrimaryExpressionFunctionCall
import ca.uottawa.csmlab.symboleo.symboleo.NegatedPrimaryExpression
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionTrue
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionFalse
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionDouble
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionInt
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionEnum
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionString
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionParameter
import ca.uottawa.csmlab.symboleo.symboleo.PrimaryExpressionRecursive
import ca.uottawa.csmlab.symboleo.symboleo.TwoArgMathFunction
import ca.uottawa.csmlab.symboleo.symboleo.OneArgMathFunction
import ca.uottawa.csmlab.symboleo.symboleo.TwoArgStringFunction
import ca.uottawa.csmlab.symboleo.symboleo.OneArgStringFunction
import ca.uottawa.csmlab.symboleo.symboleo.Obligation
import ca.uottawa.csmlab.symboleo.symboleo.Power
import ca.uottawa.csmlab.symboleo.symboleo.Variable
import ca.uottawa.csmlab.symboleo.symboleo.Proposition
import ca.uottawa.csmlab.symboleo.symboleo.POr
import ca.uottawa.csmlab.symboleo.symboleo.PAnd
import ca.uottawa.csmlab.symboleo.symboleo.PEquality
import ca.uottawa.csmlab.symboleo.symboleo.NegatedPAtom
import ca.uottawa.csmlab.symboleo.symboleo.PAtomPredicate
import ca.uottawa.csmlab.symboleo.symboleo.PAtomEnum
import ca.uottawa.csmlab.symboleo.symboleo.PAtomRecursive
import ca.uottawa.csmlab.symboleo.symboleo.PComparison
import ca.uottawa.csmlab.symboleo.symboleo.PAtomVariable
import ca.uottawa.csmlab.symboleo.symboleo.PAtomPredicateTrueLiteral
import ca.uottawa.csmlab.symboleo.symboleo.PAtomPredicateFalseLiteral
import ca.uottawa.csmlab.symboleo.symboleo.PAtomIntLiteral
import ca.uottawa.csmlab.symboleo.symboleo.PAtomStringLiteral
import java.util.HashMap
import ca.uottawa.csmlab.symboleo.symboleo.PAtomDoubleLiteral
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunction
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionHappens
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionHappensWithin
import ca.uottawa.csmlab.symboleo.symboleo.Event
import ca.uottawa.csmlab.symboleo.symboleo.VariableEvent
import ca.uottawa.csmlab.symboleo.symboleo.PowerEvent
import ca.uottawa.csmlab.symboleo.symboleo.ObligationEvent
import ca.uottawa.csmlab.symboleo.symboleo.ContractEvent
import ca.uottawa.csmlab.symboleo.symboleo.PointExpression
import ca.uottawa.csmlab.symboleo.symboleo.PointAtomParameterDotExpression
import ca.uottawa.csmlab.symboleo.symboleo.PointFunction
import ca.uottawa.csmlab.symboleo.symboleo.PointAtomObligationEvent
import ca.uottawa.csmlab.symboleo.symboleo.PointAtomContractEvent
import ca.uottawa.csmlab.symboleo.symboleo.PointAtomPowerEvent
import ca.uottawa.csmlab.symboleo.symboleo.IntervalExpression
import ca.uottawa.csmlab.symboleo.symboleo.IntervalFunction
import ca.uottawa.csmlab.symboleo.symboleo.ObligationState
import ca.uottawa.csmlab.symboleo.symboleo.PowerState
import ca.uottawa.csmlab.symboleo.symboleo.ContractState
import ca.uottawa.csmlab.symboleo.symboleo.SituationExpression
import ca.uottawa.csmlab.symboleo.symboleo.Timevalue
import ca.uottawa.csmlab.symboleo.symboleo.TimevalueInt
import ca.uottawa.csmlab.symboleo.symboleo.TimevalueVariable
import ca.uottawa.csmlab.symboleo.symboleo.ThreeArgStringFunction
import ca.uottawa.csmlab.symboleo.symboleo.ThreeArgDateFunction
import ca.uottawa.csmlab.symboleo.Helpers
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionSHappensBefore
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionWHappensBefore
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionDate
import ca.uottawa.csmlab.symboleo.symboleo.PAtomDateLiteral
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionHappensAfter
import ca.uottawa.csmlab.symboleo.symboleo.ParameterType
import ca.uottawa.csmlab.symboleo.symboleo.PowerFunction

//
/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SymboleoGenerator extends AbstractGenerator {

  val assets = new ArrayList<RegularType>
  val events = new ArrayList<RegularType>
  val roles = new ArrayList<RegularType>
  val enumerations = new ArrayList<Enumeration>
  val parameters = new ArrayList<Parameter>
  val variables = new ArrayList<Variable>
  
  val conditionalObligations = new ArrayList<Obligation>
  val conditionalSurvivingObligations = new ArrayList<Obligation>
  val conditionalPowers = new ArrayList<Power>
  
  val unconditionalObligations = new ArrayList<Obligation>
  val unconditionalSurvivingObligations = new ArrayList<Obligation>
  val unconditionalPowers = new ArrayList<Power>
  
  val untriggeredObligations = new ArrayList<Obligation>
  val untriggeredSurvivingObligations = new ArrayList<Obligation>
  val untriggeredPowers = new ArrayList<Power>
  
  val triggeredObligations = new ArrayList<Obligation>
  val triggeredSurvivingObligations = new ArrayList<Obligation>
  val triggeredPowers = new ArrayList<Power>
  
  val allObligations = new ArrayList<Obligation>
  val allSurvivingObligations = new ArrayList<Obligation>
  val allPowers = new ArrayList<Power>

  val eventVariables = new ArrayList<Variable>

  val obligationTriggerEvents = new HashMap<Obligation, List<PAtomPredicate>>
  val survivingObligationTriggerEvents = new HashMap<Obligation, List<PAtomPredicate>>
  val powerTriggerEvents = new HashMap<Power, List<PAtomPredicate>>

  val obligationAntecedentEvents = new HashMap<Obligation, List<PAtomPredicate>>
  val survivingObligationAntecedentEvents = new HashMap<Obligation, List<PAtomPredicate>>
  val powerAntecedentEvents = new HashMap<Power, List<PAtomPredicate>>

  val obligationFullfilmentEvents = new HashMap<Obligation, List<PAtomPredicate>>
  val survivingObligationFullfilmentEvents = new HashMap<Obligation, List<PAtomPredicate>>
  
  val preconditions = new ArrayList<Proposition>
  val postconditions = new ArrayList<Proposition>
  val constraints = new ArrayList<Proposition>

  def void generateHFSource(IFileSystemAccess2 fsa, Model model) {
    parse(model)
    compileDomainTypes(fsa, model)
  }

  def void parse(Model model) {
    parameters.addAll(model.parameters)
    variables.addAll(model.variables)

    for (domainType : model.domainTypes) {
      if (domainType instanceof RegularType) {
        var RegularType base = Helpers.getBaseType(domainType)
        if (base !== null) {
          switch base.ontologyType.name {
            case 'Asset': assets.add(domainType as RegularType)
            case 'Event': events.add(domainType as RegularType)
            case 'Role': roles.add(domainType as RegularType)
          }
        }
      } else if (domainType instanceof Enumeration) {
        enumerations.add(domainType as Enumeration)
      }
    }

    // event variables
    for (variable : model.variables) {
      if (events.indexOf(variable.type) != -1) {
        eventVariables.add(variable)
      }
    }

    // filtering conditional and untriggered obligations and powers
    for (obligation : model.obligations) {
      if (obligation.trigger !== null) {
        untriggeredObligations.add(obligation)
      } else {
        triggeredObligations.add(obligation)
      }
      if (obligation.antecedent instanceof PAtomPredicateTrueLiteral) {
        unconditionalObligations.add(obligation)
      } else {
        conditionalObligations.add(obligation)
      }
    }
    for (obligation : model.survivingObligations) {
      if (obligation.trigger !== null) {
        untriggeredSurvivingObligations.add(obligation)
      } else {
        triggeredSurvivingObligations.add(obligation)
      }
      if (obligation.antecedent instanceof PAtomPredicateTrueLiteral) {
        unconditionalSurvivingObligations.add(obligation)
      } else {
        conditionalSurvivingObligations.add(obligation)
      }
    }
    for (power : model.powers) {
      if (power.trigger !== null) {
        untriggeredPowers.add(power)
      } else {
        triggeredPowers.add(power)
      }
      if (power.antecedent instanceof PAtomPredicateTrueLiteral) {
        unconditionalPowers.add(power)
      } else {
        conditionalPowers.add(power)
      }
    }
    
    allObligations.addAll(untriggeredObligations)
    allObligations.addAll(triggeredObligations)
    allSurvivingObligations.addAll(untriggeredSurvivingObligations)
    allSurvivingObligations.addAll(triggeredSurvivingObligations)
    allPowers.addAll(untriggeredPowers)
    allPowers.addAll(triggeredPowers)

    // collect trigger events
    for (obligation : untriggeredObligations) {
      val proposition = obligation.trigger
      val list = collectPropositionEvents(proposition)
      if (list.size > 0) {
        obligationTriggerEvents.put(obligation, list)
      }
    }
    for (obligation : untriggeredSurvivingObligations) {
      val proposition = obligation.trigger
      val list = collectPropositionEvents(proposition)
      if (list.size > 0) {
        survivingObligationTriggerEvents.put(obligation, list)
      }
    }
    for (power : untriggeredPowers) {
      val proposition = power.trigger
      val list = collectPropositionEvents(proposition)
      if (list.size > 0) {
        powerTriggerEvents.put(power, list)
      }
    }
    // collect fulfillment events of obligations
    for (obligation : allObligations) {
      val proposition = obligation.consequent
      val list = collectPropositionEvents(proposition)
      if (list.size > 0) {
        obligationFullfilmentEvents.put(obligation, list)
      }
    }
    for (obligation : allSurvivingObligations) {
      val proposition = obligation.consequent
      val list = collectPropositionEvents(proposition)
      if (list.size > 0) {
        survivingObligationFullfilmentEvents.put(obligation, list)
      }
    }
    // collect antecedent activates 
    for (obligation : conditionalObligations) {
      val proposition = obligation.antecedent
      val list = collectPropositionEvents(proposition)
      if (list.size > 0) {
        obligationAntecedentEvents.put(obligation, list)
      }
    }
    for (obligation : conditionalSurvivingObligations) {
      val proposition = obligation.antecedent
      val list = collectPropositionEvents(proposition)
      if (list.size > 0) {
        survivingObligationAntecedentEvents.put(obligation, list)
      }
    }
    for (power : conditionalPowers) {
      val proposition = power.antecedent
      val list = collectPropositionEvents(proposition)
      if (list.size > 0) {
        powerAntecedentEvents.put(power, list)
      }
    }
    
    preconditions.addAll(model.preconditions)
    postconditions.addAll(model.postconditions)
    constraints.addAll(model.constraints)

  }
  
  
  private def boolean isSurvivingObligation (String name) {
    for (obligation: allObligations){
      if(obligation.name.equals(name)){
        return false
      }
    }
    for (obligation: allSurvivingObligations){
      if(obligation.name.equals(name)){
        return true
      }
    }
  }

  def List<PAtomPredicate> collectPropositionEvents(Proposition proposition) {
    val list = new ArrayList<PAtomPredicate>
    switch (proposition) {
      POr: {
        list.addAll(collectPropositionEvents(proposition.left))
        list.addAll(collectPropositionEvents(proposition.right))
      }
      PAnd: {
        list.addAll(collectPropositionEvents(proposition.left))
        list.addAll(collectPropositionEvents(proposition.right))
      }
      PEquality: {
        list.addAll(collectPropositionEvents(proposition.left))
        list.addAll(collectPropositionEvents(proposition.right))
      }
      PComparison: {
        list.addAll(collectPropositionEvents(proposition.left))
        list.addAll(collectPropositionEvents(proposition.right))
      }
      PAtomRecursive:
        list.addAll(collectPropositionEvents(proposition.inner))
      NegatedPAtom:
        list.addAll(collectPropositionEvents(proposition.negated))
      PAtomPredicate:
        list.add(proposition)
    }
    return list
  }

  def String generatePredicateFunctionString(PredicateFunction predicate) {
    switch (predicate) {
      PredicateFunctionHappens: return '''Predicates.happens(«generateEventVariableString(predicate.event)»)'''
      PredicateFunctionHappensAfter: return '''Predicates.happensAfter(«generateEventVariableString(predicate.event)», «generatePointExpresionString(predicate.point.pointExpression)»)'''
      PredicateFunctionWHappensBefore: return '''Predicates.weakHappensBefore(«generateEventVariableString(predicate.event)», «generatePointExpresionString(predicate.point.pointExpression)»)'''
      PredicateFunctionSHappensBefore: return '''Predicates.strongHappensBefore(«generateEventVariableString(predicate.event)», «generatePointExpresionString(predicate.point.pointExpression)»)'''
      PredicateFunctionHappensWithin: return '''Predicates.happensWithin(«generateEventVariableString(predicate.event)», «generateIntervalExpresionArgString(predicate.interval.intervalExpression)»)'''
    }
  }

  def String generateEventVariableString(Event event) {
    switch (event) {
      VariableEvent: return generateDotExpressionString(event.variable, 'contract')
      PowerEvent: return '''contract.powers.«event.powerVariable.name» && contract.powers.«event.powerVariable.name»._events.«event.eventName»'''
      ObligationEvent: return '''contract.«isSurvivingObligation(event.obligationVariable.name) ? "survivingObligations" : "obligations"».«event.obligationVariable.name» && contract.«isSurvivingObligation(event.obligationVariable.name) ? "survivingObligations" : "obligations"».«event.obligationVariable.name»._events.«event.eventName»'''
      ContractEvent: return '''contract._events.«event.eventName»'''
    }
  }

  def String generatePointExpresionString(PointExpression point) {
    switch (point) {
      PointFunction: return '''Utils.addTime(«generatePointExpresionString(point.arg)», «generateTimeValueString(point.value)», "«point.timeUnit»")'''
      PointAtomParameterDotExpression: {
        if (Helpers.isDotExpressionTypeOfEvent(point.variable, variables, parameters)) {
          return '''«generateDotExpressionString(point.variable, 'contract')»._timestamp'''
        } else {
          return generateDotExpressionString(point.variable, 'contract')
        }
        
      }
      PointAtomObligationEvent: {
        val e = point.obligationEvent as ObligationEvent
        val obligationRef = isSurvivingObligation(e.obligationVariable.name) ? "survivingObligations" : "obligations"        
        return '''contract.«obligationRef».«e.obligationVariable.name» && contract.«obligationRef».«e.obligationVariable.name»._events.«e.eventName» && contract.«obligationRef».«e.obligationVariable.name»._events.«e.eventName»._timestamp'''
      }
      PointAtomPowerEvent: {
        val e = point.powerEvent as PowerEvent
        return '''contract.powers.«e.powerVariable.name» && contract.powers.«e.powerVariable.name»._events.«e.eventName» && contract.powers.«e.powerVariable.name»._events.«e.eventName»._timestamp'''
      }
      PointAtomContractEvent: {
        val e = point.contractEvent as ContractEvent
        return '''contract._events.«e.eventName» && contract._events.«e.eventName»._timestamp'''
      }
    }
  }

  def String generateTimeValueString(Timevalue tv) {
    switch (tv) {
      TimevalueInt: return tv.value.toString
      TimevalueVariable: return generateDotExpressionString(tv.variable, 'contract')
    }
  }

  def String generateIntervalExpresionArgString(IntervalExpression interval) {
    switch (interval) {
      IntervalFunction:
        return '''«generatePointExpresionString(interval.arg1)», «generatePointExpresionString(interval.arg2)»'''
      SituationExpression: {
        val situation = interval.situation
        switch (situation) {
          ObligationState: return '''contract.«isSurvivingObligation(situation.obligationVariable.name) ? "survivingObligations" : "obligations"».«situation.obligationVariable.name», "Obligation.«situation.stateName»"'''
          PowerState: return '''contract.powers.«situation.powerVariable.name», "Power.«situation.stateName»""'''
          ContractState: return '''contract, "Contract.«situation.stateName»"'''
        }
      }
    }
  }
 

  // Concerto expression string generation
  def String generateExpressionString(Expression argExpression, String thisString) {
    switch (argExpression) {
      Or:
        return generateExpressionString(argExpression.left, thisString) + " or " +
          generateExpressionString(argExpression.right, thisString)
      And:
        return generateExpressionString(argExpression.left, thisString) + " and " +
          generateExpressionString(argExpression.right, thisString)
      Equality:
        return generateExpressionString(argExpression.left, thisString) + argExpression.op +
          generateExpressionString(argExpression.right, thisString)
      Comparison:
        return generateExpressionString(argExpression.left, thisString) + argExpression.op +
          generateExpressionString(argExpression.right, thisString)
      Plus:
        return generateExpressionString(argExpression.left, thisString) + " + " +
          generateExpressionString(argExpression.right, thisString)
      Minus:
        return generateExpressionString(argExpression.left, thisString) + " - " +
          generateExpressionString(argExpression.right, thisString)
      Multi:
        return generateExpressionString(argExpression.left, thisString) + " * " +
          generateExpressionString(argExpression.right, thisString)
      Div:
        return generateExpressionString(argExpression.left, thisString) + " / " +
          generateExpressionString(argExpression.right, thisString)
      PrimaryExpressionRecursive:
        return "(" + generateExpressionString(argExpression.inner, thisString) + ")"
      PrimaryExpressionFunctionCall:
        return generateFunctionCall(argExpression, thisString)
      NegatedPrimaryExpression:
        return "not (" + generateExpressionString(argExpression.expression, thisString) + ")"
      AtomicExpressionTrue:
        return "true"
      AtomicExpressionFalse:
        return "false"
      AtomicExpressionDouble:
        return argExpression.value.toString()
      AtomicExpressionInt:
        return argExpression.value.toString()
      AtomicExpressionDate:
        return '''(new Date("«argExpression.value.toInstant.toString»").toISOString())'''
      AtomicExpressionEnum:
        return argExpression.enumeration.name + "." + argExpression.enumItem.name
      AtomicExpressionString:
        return '"' + argExpression.value + '"'
      AtomicExpressionParameter:
        return generateDotExpressionString(argExpression.value, thisString)
    }
  }

  def String generatePropositionString(Proposition proposition) {
    switch (proposition) {
      POr:
        return generatePropositionString(proposition.left) + "or" + generatePropositionString(proposition.right)
      PAnd:
        return generatePropositionString(proposition.left) + "and" + generatePropositionString(proposition.right)
      PEquality:
        return generatePropositionString(proposition.left) + proposition.op +
          generatePropositionString(proposition.right)
      PComparison:
        return generatePropositionString(proposition.left) + proposition.op +
          generatePropositionString(proposition.right)
      PAtomRecursive:
        return "(" + generatePropositionString(proposition.inner) + ")"
      NegatedPAtom:
        return "not(" + generatePropositionString(proposition.negated) + ")"
      PAtomPredicate:
        return generatePredicateFunctionString(proposition.predicateFunction)
      PAtomEnum:
        return proposition.enumeration.name + "." + proposition.enumItem.name
      PAtomVariable:
        return generateDotExpressionString(proposition.variable, 'contract')
      PAtomPredicateTrueLiteral:
        return "true"
      PAtomPredicateFalseLiteral:
        return "false"
      PAtomDoubleLiteral:
        return proposition.value.toString
      PAtomIntLiteral:
        return proposition.value.toString
      PAtomDateLiteral:
        return '''(new Date("«proposition.value.toInstant.toString»").toISOString())'''
      PAtomStringLiteral:
        return proposition.value
    }
  }

  def String generateDotExpressionString(Ref argRef, String thisString) {
    val ids = new ArrayList<String>()
    var ref = argRef
    while (ref instanceof VariableDotExpression) {
      ids.add(ref.tail.name)
      ref = ref.ref
    }
    if (ref instanceof VariableRef) {
      ids.add((ref as VariableRef).variable)
    }
    ids.add(thisString)
    //return ids.reverse().join(".")
    return ids.get(0)
  }
  
  // CONCERTO GENERATE OBLIGATION CREDITOR TYPE
  def String generateRefTypeString(Ref argRef) {
    val ids = new ArrayList<String>()
    var ref = argRef
    while (ref instanceof VariableDotExpression) {
      ids.add(ref.tail.name)
      ref = ref.ref
    }
	var type = ""
    if (ref instanceof VariableRef) {
      var x = (ref as VariableRef).variable
      ids.add((ref as VariableRef).variable)
      for (p : parameters) {
      	if(p.getName.equals(x)){
      		if(p.getType.getBaseType !== null) {
      			type = p.getType.getBaseType.getName	
      		}
      		else {
      			type = p.getType.getDomainType.getName
      		}
      	}
      }
      for (v : variables) {
      	if(v.getName.equals(x)){
      		type = v.getType.getName
      	}
      }
    }
    return type + " " + ids.reverse().join(".")
  }
  
  def String generateType(ParameterType type) {
	if(type.getBaseType!== null)
		if(type.getBaseType.getName.equals("Number"))
			return "Integer"
		else if(type.getBaseType.getName.equals("Date"))
			return "DateTime"
		else
			return type.getBaseType.getName
	else
		return type.getDomainType.getName
  }

  // CONCERTO INPUT PARAMETERS CONTRACT 
  def String generateInputContract()'''
  	asset InputContract {
  		«FOR p : parameters»
  		o «generateType(p.type)» «p.name»  
  		«ENDFOR»
  		}
  	
  	'''
  	
  def String generatePowerFunction(PowerFunction pf)'''
		«pf.getAction» 
  '''
  
  def String generateVariables()'''
  	«FOR v : variables»
  		let «v.getName» = «v.getType.name» { 
  		«val attr = v.getAttributes»
  		«FOR a : attr SEPARATOR ','» 
  			«(a as AssignExpression).name» : «generateExpressionString((a as AssignExpression).value,"")»
		«ENDFOR»
	«ENDFOR»
  '''
  
  def String generateObligations()'''
    «FOR o : allObligations»
    	obl «o.getName» = 
    		«IF o.trigger !== null» 
    			«generatePropositionString(o.trigger)» -> 
    		«ENDIF»
    		O(«generateDotExpressionString(o.debtor,"")», «generateDotExpressionString(o.creditor,"")», «generatePropositionString(o.antecedent)», «generatePropositionString(o.consequent)»); 
  	«ENDFOR»
  '''
  
  def String generateSurvivingObligations()'''
    «FOR o : allSurvivingObligations»
    	sobl «o.getName» = 
    		«IF o.trigger !== null» 
    			«generatePropositionString(o.trigger)» -> 
    		«ENDIF»
    		O(«generateDotExpressionString(o.debtor,"")», «generateDotExpressionString(o.creditor,"")», «generatePropositionString(o.antecedent)», «generatePropositionString(o.consequent)»); 
  	«ENDFOR»
  '''
  
  def String generatePowers()'''
    «FOR o : allPowers»
    	pow «o.getName» = 
    		«IF o.trigger !== null» 
    			«generatePropositionString(o.trigger)» -> 
    		«ENDIF»
    		P(«generateDotExpressionString(o.debtor,"")», «generateDotExpressionString(o.creditor,"")», «generatePropositionString(o.antecedent)», «generatePowerFunction(o.consequent)»); 
  	«ENDFOR»
  '''
  
  def String generatePrePostConst(ArrayList<Proposition> prop, String keyword)'''
  	«FOR o : prop»
  	    «keyword» «generatePropositionString(o)»;
  	 «ENDFOR»
  '''
  
  // ERGo generation
  def String generateLogic()'''
  	contract MyLogic over InputContract {
  		clause contract(request : InputContract) : null {
  			«generateVariables()»
  			«generateObligations()»
  			«generateSurvivingObligations()»
  			«generatePowers()»
  			«generatePrePostConst(preconditions, "pre")»
  			«generatePrePostConst(preconditions, "post")»
  			«generatePrePostConst(preconditions, "constr")»
  		};
  	
  	'''
  	
  def String generateFunctionCall(PrimaryExpressionFunctionCall argFunctionCallExp, String thisString) {
    val functionCall = argFunctionCallExp.function
    switch (functionCall) {
      TwoArgMathFunction:
        return functionCall.name + "(" + generateExpressionString(functionCall.arg1, thisString) + "," +
          generateExpressionString(functionCall.arg2, thisString) + ")"
      OneArgMathFunction:
        return functionCall.name + "(" + generateExpressionString(functionCall.arg1, thisString) + ")"
      ThreeArgStringFunction:
        return functionCall.name.replace("String", "Str") + "(" + generateExpressionString(functionCall.arg1, thisString) + "," +
          generateExpressionString(functionCall.arg2, thisString) + "," + generateExpressionString(functionCall.arg3, thisString) + ")"
      TwoArgStringFunction:
        return functionCall.name.replace("String", "Str") + "(" + generateExpressionString(functionCall.arg1, thisString) + "," +
          generateExpressionString(functionCall.arg2, thisString) + ")"
      OneArgStringFunction:
        return functionCall.name.replace("String", "Str") + "(" + generateExpressionString(functionCall.arg1, thisString) + ")"
      ThreeArgDateFunction:
        return '''Utils.addTime(«generateExpressionString(functionCall.arg1, thisString)», «generateExpressionString(functionCall.value, thisString)», "«functionCall.timeUnit»")'''
    }
  }

  // changed compileDomainTypes to fit concerto generation
  def void compileDomainTypes(IFileSystemAccess2 fsa, Model model) {
    val StringBuilder concertoString = new StringBuilder();
    val StringBuilder contractString = new StringBuilder();
    concertoString.append("namespace studentContract \n\n")
    contractString.append("asset " + model.getDomainName + " extends Contract {")
	for (role : roles) {
      concertoString.append(generateRoleConcerto(model, role))
      contractString.append("\n\to " + role.getName + " " + role.getName.toLowerCase) 
    }
    for (event : events) {
      concertoString.append(generateEventConcerto(model, event))
      contractString.append("\n\to " + event.getName + " " + event.getName.toLowerCase)
    }
    for (asset : assets) {
      concertoString.append(generateAssetConcerto(model, asset))
      contractString.append("\n\to " + asset.getName + " " + asset.getName.toLowerCase)
    }
    contractString.append("\n}\n\n")
    concertoString.append(contractString)
    concertoString.append(generateInputContract)
    
    for (enumeration : enumerations) {
      concertoString.append(generateEnumerationConcerto(model, enumeration))
    }
    fsa.generateFile("./" + model.contractName + "/domain/model.cto", concertoString.toString())
    fsa.generateFile("./" + model.contractName + "logic.ergo", generateLogic)
  }
 

  // CONCERTO CHAR SEQUENCE GENERATION FOR OBLIGATION (GENERATES TO EVENT)
  def CharSequence generateObligationConcerto(Model model, Obligation obligation) {
  	val code = '''
  	event «obligation.name» {
  		o «generateRefTypeString(obligation.debtor)»
  		o «generateRefTypeString(obligation.creditor)»
«««  		o «generatePropositionString(obligation.antecedent)»
		o Boolean antecedent
		o Boolean «generatePropositionString(obligation.consequent)»
  	}
  	
  	'''
  	
  	return code
  }
  
  // CONCERTO CHAR SEQUENCE GENERATION FOR ENUMERATION
  def CharSequence generateEnumerationConcerto(Model model, Enumeration enumeration) {
  	val code = '''      
      enum «enumeration.name» {
        «FOR item : enumeration.enumerationItems»
        	o «item.name»
        «ENDFOR»
      }
      
    '''
    return code;
  }

  // CONCERTO CHAR SEQUENCE GENERATION FOR ASSET
  def CharSequence generateAssetConcerto(Model model, RegularType asset) {
    val code = '''
  	asset «asset.name» {
  		«FOR attribute : asset.attributes»
  		«IF attribute.getBaseType !== null »
  			«IF attribute.getBaseType.getName.equals("Number")» 
  				o Integer «attribute.name»
  			«ELSEIF attribute.getBaseType.getName.equals("Date")»
  				o DateTime «attribute.name»
			«ELSE»
  			o «attribute.getBaseType.getName» «attribute.name»
			«ENDIF»
		«ELSE»
  		o «attribute.getDomainType.getName» «attribute.name»
		«ENDIF»
  		«ENDFOR»
  	}
  	
  	'''
  	return code
  }

  // CONCERTO CHAR SEQUENCE GENERATION FOR EVENT (GENERATES TO CONCEPT)
  def CharSequence generateEventConcerto(Model model, RegularType event) {
  	val code = '''
  	concept «event.name» {
  		«FOR attribute : event.attributes»
  		«IF attribute.getBaseType !== null »
  			«IF attribute.getBaseType.getName.equals("Number")» 
  				o Integer «attribute.name»
  			«ELSEIF attribute.getBaseType.getName.equals("Date")»
  				o DateTime «attribute.name»
			«ELSE»
  			o «attribute.getBaseType.getName» «attribute.name»
			«ENDIF»
		«ELSE»
  		o «attribute.getDomainType.getName» «attribute.name»
		«ENDIF»
  		«ENDFOR»
  	}
  	
  	'''
  	return code
  }
  
  // CONCERTO CHAR SEQUENCE GENERATION FOR ROLE (GENERATES TO PARTICIPANT)
  def CharSequence generateRoleConcerto(Model model, RegularType role) {
     val code = '''  
	 participant «role.name» {
	 	«FOR attribute : role.attributes»
  		«IF attribute.getBaseType !== null »
  			«IF attribute.getBaseType.getName.equals("Number")» 
  				o Integer «attribute.name»
			«ELSEIF attribute.getBaseType.getName.equals("Date")»
  				o DateTime «attribute.name»
			«ELSE»
  			o «attribute.getBaseType.getName» «attribute.name»
			«ENDIF»
		«ELSE»
  		o «attribute.getDomainType.getName» «attribute.name»
		«ENDIF»
  		«ENDFOR»
	 }
	 
	 '''
  	 return code;
  }

  override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
    for (e : resource.allContents.toIterable.filter(Model)) {
      assets.clear()
      events.clear()
      roles.clear()
      enumerations.clear()
      parameters.clear()

      conditionalObligations.clear()
      conditionalSurvivingObligations.clear()
      conditionalPowers.clear()
                                              
      unconditionalObligations.clear()
      unconditionalSurvivingObligations.clear()
      unconditionalPowers.clear()
                                              
      untriggeredObligations.clear()
      untriggeredSurvivingObligations.clear()
      untriggeredPowers.clear()
      
      
      triggeredObligations.clear()
      triggeredSurvivingObligations.clear()
      triggeredPowers.clear()
      
      allObligations.clear()
      allSurvivingObligations.clear()
      allPowers.clear()

      eventVariables.clear()

      obligationTriggerEvents.clear()
      survivingObligationTriggerEvents.clear()
      powerTriggerEvents.clear()

      obligationAntecedentEvents.clear()
      survivingObligationAntecedentEvents.clear()
      powerAntecedentEvents.clear()

      obligationFullfilmentEvents.clear()
      survivingObligationFullfilmentEvents.clear()

      System.out.println('generateHFSource: ' + e.contractName)
      generateHFSource(fsa, e)
    }
  }

  override void afterGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
    assets.clear()
    events.clear()
    roles.clear()
    enumerations.clear()
    parameters.clear()
    
    conditionalObligations.clear()
    conditionalSurvivingObligations.clear()
    conditionalPowers.clear()
                                              
    unconditionalObligations.clear()
    unconditionalSurvivingObligations.clear()
    unconditionalPowers.clear()
                                              
    untriggeredObligations.clear()
    untriggeredSurvivingObligations.clear()
    untriggeredPowers.clear()

    triggeredObligations.clear()
    triggeredSurvivingObligations.clear()
    triggeredPowers.clear()
    
    allObligations.clear()
    allSurvivingObligations.clear()
    allPowers.clear()

    eventVariables.clear()

    obligationTriggerEvents.clear()
    survivingObligationTriggerEvents.clear()
    powerTriggerEvents.clear()

    obligationAntecedentEvents.clear()
    survivingObligationAntecedentEvents.clear()
    powerAntecedentEvents.clear()

    obligationFullfilmentEvents.clear()
    survivingObligationFullfilmentEvents.clear()
  }
}